/*
  Copyright 2013-2017 Wix.com

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
 */

package com.wix.accord

import com.wix.accord.transform.ValidationTransform.TransformedValidator

import scala.language.implicitConversions
import scala.language.experimental.macros
import com.wix.accord.transform.ValidationTransform

/** Provides a DSL for defining validation rules.
  *
  * ==Overview==
  *
  * Accord provides a convenient DSL for defining validation rules. To define a validator over some type `T`,
  * import this package and invoke [[com.wix.accord.dsl.validator() validator[T]]]. You can then use the
  * provided sample object to define various rules:
  *
  * {{{
  *   scala> case class Person( name: String, age: Int )
  *   defined class Person
  *
  *   scala> import com.wix.accord.dsl._    // Import the validator DSL
  *   import com.wix.accord.dsl._
  *
  *   scala> implicit val personValidator = validator[ Person ] { p =>
  *        |   // Validation rules:
  *        |   p.name is notEmpty
  *        |   p.age should be >= 18
  *        | }
  *   personValidator: com.wix.accord.transform.ValidationTransform.TransformedValidator[Person] = <function1>
  * }}}
  *
  * Accord adds an implicit logical `and` relation between the rules, so all rules must apply in order
  * for the validation to be successful. You can specify as many rules as you like.
  *
  * ==Descriptions==
  *
  * Each validation rule has an associated description (accessible via [[com.wix.accord.Violation.description]]).
  * This description is automatically generated by Accord:
  *
  * {{{
  *   scala> import com.wix.accord._
  *   import com.wix.accord._
  *
  *   scala> validate( Person( "", 15 ) )
  *   res1: com.wix.accord.Result = Failure(Set(RuleViolation(,must not be empty,Some(name)), RuleViolation(15,got 15, expected 18 or more,Some(age))))
  * }}}
  *
  * You can also explicitly provide a description with the [[com.wix.accord.dsl.Descriptor.as "as" modifier]]:
  *
  * {{{
  *   scala> implicit val personValidator = validator[ Person ] { p =>
  *        |   p.name as "Full name" is notEmpty
  *        |   p.age as "Age" should be >= 18
  *        | }
  *   personValidator: com.wix.accord.transform.ValidationTransform.TransformedValidator[Person] = <function1>
  *
  *   scala> validate( Person( "", 15 ) )
  *   res2: com.wix.accord.Result = Failure(Set(RuleViolation(,must not be empty,Some(Full name)), RuleViolation(15,got 15, expected 18 or more,Some(Age))))
  * }}}
  *
  *
  * ==Combinators==
  *
  * Accord offers a built-in library of building blocks (called "combinators") that can be composed
  * into more complex validation rules:
  *
  * ===General-purpose===
  *
  * {{{
  *   // Equality
  *   sample.field is equalTo( "value" )
  *   sample.field is notEqualTo( "value" )
  *
  *   // Nullability (only applies to reference types)
  *   sample.field is aNull
  *   sample.field is notNull
  *
  *   // Delegation
  *   sample.field is valid    					// Implicitly, or
  *   sample.field is valid( myOwnValidator )		// Explicitly
  * }}}
  *
  *
  * ===Primitives===
  *
  * {{{
  *   // Booleans
  *   sample.booleanField is true
  *   sample.booleanField is false
  *
  *   // Strings
  *   sample.stringField should startWith( "prefix" )
  *   sample.stringField should endWith( "suffix" )
  *   sample.stringField should matchRegex( "b[aeiou]t" )       // Matches "bat" and "dingbat"
  *   sample.stringField should matchRegexFully( "b[aeiou]t" )  // Matches "bat" but not "dingbat"
  *   sample.stringField should matchRegex( pattern )           // You can also use java.util.regex.Pattern
  *   sample.stringField should matchRegex( regex )             // ... or scala.util.matching.Regex
  *   sample.stringField is blank                               // Matches empty or whitespace-only strings
  *   sample.stringField is notBlank
  *
  *   // You can use "must" instead of "should":
  *   sample.stringField must startWith( "prefix" )
  *
  *   // Strings are also "collection-like", so all collection combinators apply (see below)
  *   sample.stringField is notEmpty
  *
  *   // Numerics (applies to any type with an instance of scala.math.Ordering in implicit search scope):
  *   sample.intField should be < 5
  *   sample.intField should be > 5
  *   sample.intField should be <= 5
  *   sample.intField should be >= 5
  *   sample.intField should be == 5
  *   sample.intField is between( 0, 10 )
  *   sample.intField is between( 0, 10 ).exclusive
  *   sample.intField is within( 0 to 10 )              // Inclusive
  *   sample.intField is within( 0 until 10 )           // Exclusive
  * }}}
  *
  * ===Collections===
  *
  * {{{
  *   // Emptiness
  *   sample.seq is empty
  *   sample.seq is notEmpty
  *
  *   // This applies to any type that has a boolean "isEmpty" property, such as string)
  *   // The "each" modifier applies the validation to all members of a collection:
  *   sample.seq.each should be >= 10
  *   sample.option.each should be >= 10                // Allows None or Some(15)
  *
  *   // Size (applies to any type with an integer "size" property)
  *   // See "Numerics" above for additional operations
  *   sample.seq has size >= 8
  *   sample.entities have size >= 8		// You can use "have" in place of "has"
  * }}}
  *
  * ===Boolean Expressions===
  *
  * {{{
  *   // Logical AND (not strictly required, since you can just split into separate rules)
  *   ( person.name is notEmpty ) and ( person.age should be >= 18 )
  *
  *   // Logical OR
  *   ( person.email is notEmpty ) or ( person.phoneNumber is notEmpty )
  *
  *   // You can also nest rules:
  *   ( fromJava.tags is aNull ) or (
  *     ( fromJava.tags is notEmpty ) and
  *     ( fromJava.tags.each should matchRegexFully( "\\S+" ) )
  *   )
  *
  */
package object dsl
  extends StringOps
     with CollectionOps
     with GenericOps
     with OrderingOps
     with BooleanOps {

  /** Defines a new validator for the specified type.
    *
    * This function takes a block of validation rules (encoded as a "thunk"), and rewrites them as a full-fledged
    * instance of [[com.wix.accord.Validator Validator]]. A full example and details of the available syntax can
    * be found in the [[com.wix.accord.dsl package documentation]].
    *
    * Details of the code transformation are documented in
    * [[com.wix.accord.transform.ValidationTransform ValidationTransform]] (fair warning: this description is quite
    * low-level and fairly involved, and will likely not be of interest to most users).
    *
    * @param v The validation code block; may contain any combination of validation statements.
    * @tparam T The type under validation.
    * @return The validation code block rewritten as a [[com.wix.accord.Validator]] for the specified type `T`.
    * @see com.wix.accord.dsl
    */
  def validator[ T ]( v: T => Unit ): TransformedValidator[ T ] = macro ValidationTransform.apply[ T ]

  /** Wraps expressions under validation with the Accord DSL.
    *
    * This class provides the entry point into the DSL, by wrapping an expression with a specialized scope
    * (this is later used during the macro transform). This enables syntax such as `p.firstName is notEmpty`,
    * where `p.firstName` is the actual expression under validation.
    *
    * See the [[com.wix.accord.dsl package documentation]] for a full description of the DSL.
    *
    * @param value The value to wrap with a validation context.
    * @tparam U The type of the provided expression.
    * @see com.wix.accord.dsl
    */
  implicit class Contextualizer[ U ]( value: U ) extends SimpleDslContext[ U ]

  /** Enables explicitly describing expression under validation.
    *
    * After the macro transform, the resulting validator will use the specified description to
    * render violations. See the [[com.wix.accord.dsl.Descriptor.as as]] method for full example.
    *
    * @param value The value to wrap with an explicit description.
    * @tparam U The type of the provided expression.
    * @see com.wix.accord.dsl
    */
  implicit class Descriptor[ U ]( value: U ) {
    /** Tags the specified validation expression with an explicit description. Enables syntax such as:
      * `p.firstName as "first name" is notEmpty`; violations for this validation rule will be rendered with the
      * specified expression (instead of the implicit rule), for example:
      *
      *
      *
      *
      * --- TODO --- update example!
      *
      *
      *
      * {{{
      *   scala> case class Person( firstName: String, lastName: String )
      *   defined class Person
      *
      *   scala> implicit val personValidator = validator[ Person ] { p => p.firstName as "first name" is notEmpty }
      *   personValidator: com.wix.accord.combinators.And[Person] = <function1>
      *
      *   scala> validate( Person( "", "last" ) )
      *   res0: com.wix.accord.Result = Failure(List(Violation(first name must not be empty,)))
      * }}}
      *
      * Without the explicit description, the violation would read "firstName must not be empty".
      *
      * @param description The description to use for the expression in case of violations.
      * @return The validation expression tagged with the explicit description.
      */
    def as( description: String ): U = value
  }

  /** Provides the "be" keyword.
    *
    * Makes all members of [[com.wix.accord.dsl.OrderingOps OrderingOps]] accessible via the following syntax:
    *
    * {{{
    *   p.age should be > 5`
    * }}}
    *
    * @see com.wix.accord.dsl.OrderingOps
    */
  val be: OrderingOps = this
}
